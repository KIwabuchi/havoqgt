<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>HavoqGT: Developer Guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">HavoqGT
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('developer_guide.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Developer Guide </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This section of the guide is intended to help developers design new graph algorithms using the HavoqGT framework. It is assumed that you've read the <a class="el" href="getting_started.html">Getting Started</a> sections, and are familiar with basic compiling and running. After introducing the <a class="el" href="developer_guide.html#developer_visitor_queue">Visitor Queue</a>, this section concludes with a <a class="el" href="developer_guide.html#bfs_example">BFS Example</a>.</p>
<h1><a class="anchor" id="developer_visitor_queue"></a>
Visitor Queue</h1>
<p>Our framework uses an asynchronous visitor queue abstraction. The visitor queue provides the parallelism and creates a data-driven flow of computation. Traversal algorithm developers define vertex-centric procedures to execute on traversed vertices. Vertex visitors have the ability to pass visitor state to other vertices.</p>
<p>Each asynchronous traversal begins with an initial set of visitors, which may create additional visitors dynamically depending on the algorithm and graph topology. All visitors are asynchronously transmitted, scheduled, and executed. When the visitors execute on a vertex, they are guaranteed exclusive access to the vertexâ€™s data. The traversal completes when all visitors have completed, and the distributed queue is globally empty.</p>
<p>Additional documentation for components of the visitor queue can be found:</p><ul>
<li><a class="el" href="visitor__queue_8hpp.html">visitor_queue.hpp</a> &ndash; The visitor queue.</li>
<li><a class="el" href="mailbox_8hpp.html">mailbox.hpp</a> &ndash; The mailbox communication layer. MPI point-to-point communication with routing and aggregation.</li>
<li><a class="el" href="termination__detection_8hpp.html">termination_detection.hpp</a> &ndash; Asynchronous termination detection algorithm.</li>
</ul>
<h1><a class="anchor" id="bfs_example"></a>
BFS Example</h1>
<p>To demonstrate how an algorithm is written in HavoqGT, we walk through a simple example of Breadth-First Search. The full BFS code can be found in <a class="el" href="breadth__first__search_8hpp.html">breadth_first_search.hpp</a>.</p>
<p>An algorithm consists of two main things, a class called a <a class="el" href="developer_guide.html#bfs_visitor">Visitor</a>, and an <a class="el" href="developer_guide.html#bfs_init">Initiator</a> function.</p>
<h2><a class="anchor" id="bfs_visitor"></a>
Visitor</h2>
<p>A visitor is required to have three main functions:</p><ul>
<li>pre_visit() &ndash; Performs a preliminary evaluation of the state and returns true if the visitation should proceed, this can be applied to delegate vertices. For BFS, this simply checks if the vertex's level is greater than the visitors' level, and returns true if so. If pre_visit() returns true, the visitor is added to the Visitor Queue and its visit() function will be executed when pop'ed from the queue.</li>
<li>visit(Graph&amp; , VisitorQueueHandle ) &ndash; Main visitor procedure that is executed as a visitor is pop'ed from the top of the Visitor Queue. For BFS, this function loops over all neighbors of <em>vertex</em> and sends them a new visitors with the BFS level incremented.</li>
<li>bool operator&gt; (const visitor&amp;, const visitor&amp;) &ndash; Less than comparison used to locally prioritize the visitors in a min heap priority queue.</li>
</ul>
<p>Additional functions and data that are specific to BFS are:</p><ul>
<li>level() and parent() &ndash; these access the visitor's locally stored state holding the BFS level and BFS parent.</li>
<li>level_data() and parent_data() &ndash; these access static pointers that point to the vertex_data datastructures that are used to store the level's and parent's of each vertex.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Graph, <span class="keyword">typename</span> LevelData, <span class="keyword">typename</span> ParentData&gt;</div>
<div class="line"><span class="keyword">class </span>bfs_visitor {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Graph::vertex_locator                 vertex_locator;</div>
<div class="line"></div>
<div class="line">  bfs_visitor(): m_level(std::numeric_limits&lt;uint64_t&gt;::max())  { }</div>
<div class="line"></div>
<div class="line">  bfs_visitor(vertex_locator _vertex, uint64_t _level, vertex_locator _parent)</div>
<div class="line">    : vertex(_vertex)</div>
<div class="line">    , m_parent(_parent)</div>
<div class="line">    , m_level(_level) { }</div>
<div class="line"></div>
<div class="line">  bfs_visitor(vertex_locator _vertex)</div>
<div class="line">    : vertex(_vertex)</div>
<div class="line">    , m_parent(_vertex)</div>
<div class="line">    , m_level(0) { }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">bool</span> pre_visit()<span class="keyword"> const </span>{</div>
<div class="line">    <span class="keywordtype">bool</span> do_visit  = (*level_data())[vertex] &gt; level();</div>
<div class="line">    <span class="keywordflow">if</span>(do_visit) {</div>
<div class="line">      (*level_data())[vertex] = level();</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> do_visit;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> VisitorQueueHandle&gt;</div>
<div class="line">  <span class="keywordtype">bool</span> visit(Graph&amp; g, VisitorQueueHandle vis_queue)<span class="keyword"> const </span>{</div>
<div class="line">    <span class="keywordflow">if</span>(level() &lt;= (*level_data())[vertex]) {</div>
<div class="line">      (*level_data())[vertex] = level();</div>
<div class="line">      (*parent_data())[vertex] = parent();</div>
<div class="line"></div>
<div class="line">      <span class="keyword">typedef</span> <span class="keyword">typename</span> Graph::edge_iterator eitr_type;</div>
<div class="line">      <span class="keywordflow">for</span>(eitr_type eitr = g.edges_begin(vertex); eitr != g.edges_end(vertex); ++eitr) {</div>
<div class="line">        vertex_locator neighbor = eitr.target();</div>
<div class="line">        bfs_visitor new_visitor(neighbor, level() + 1, vertex);</div>
<div class="line">        vis_queue-&gt;queue_visitor(new_visitor);</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  uint64_t level()<span class="keyword"> const </span>{  <span class="keywordflow">return</span> m_level; }</div>
<div class="line"></div>
<div class="line">  vertex_locator parent()<span class="keyword"> const  </span>{ <span class="keywordflow">return</span> m_parent; }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">friend</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator&gt;(<span class="keyword">const</span> bfs_visitor&amp; v1, <span class="keyword">const</span> bfs_visitor&amp; v2) {</div>
<div class="line">    <span class="keywordflow">return</span> v1.level() &gt; v2.level();</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> set_level_data(LevelData* _data) { level_data() = _data; }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">static</span> LevelData*&amp; level_data() {</div>
<div class="line">    <span class="keyword">static</span> LevelData* data;</div>
<div class="line">    <span class="keywordflow">return</span> data;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> set_parent_data(ParentData* _data) { parent_data() = _data; }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">static</span> ParentData*&amp; parent_data() {</div>
<div class="line">    <span class="keyword">static</span> ParentData* data;</div>
<div class="line">    <span class="keywordflow">return</span> data;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  vertex_locator   vertex;</div>
<div class="line">  vertex_locator   m_parent;</div>
<div class="line">  uint64_t         m_level;</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="bfs_init"></a>
Initiator</h2>
<p>After a visitor has been created for an algorithm, an initiator is required to bootstrap the dataflow computation. For BFS this function first sets up a bfs_visitor with its required static state (level_data &amp; parent_data). Second, it instantiates a Visitor Queue. Finally, it initializes the visitor traversal with a source vertex.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TGraph, <span class="keyword">typename</span> LevelData, <span class="keyword">typename</span> ParentData&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="namespacehavoqgt_1_1mpi.html#a6d1b4b2ccf280b0fd4b87213f780f6c4">breadth_first_search</a>(TGraph* g,</div>
<div class="line">                          LevelData&amp; level_data,</div>
<div class="line">                          ParentData&amp; parent_data,</div>
<div class="line">                          <span class="keyword">typename</span> TGraph::vertex_locator s) {</div>
<div class="line"></div>
<div class="line">  <span class="keyword">typedef</span>  bfs_visitor&lt;TGraph, LevelData, ParentData&gt;    visitor_type;</div>
<div class="line">  visitor_type::set_level_data(&amp;level_data);</div>
<div class="line">  visitor_type::set_parent_data(&amp;parent_data);</div>
<div class="line">  <span class="keyword">typedef</span> visitor_queue&lt; visitor_type, bfs_priority_queue, TGraph &gt;    visitor_queue_type;</div>
<div class="line"></div>
<div class="line">  visitor_queue_type vq(g);</div>
<div class="line">  vq.init_visitor_traversal(s);</div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Aug 10 2016 00:55:32 for HavoqGT by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
